//
// Created by chen on 2019/8/6.
//

//回文数
/*
一个正整数，如果交换高低位以后和原数相等，那么称这个数为回文数。比如121，2332都是回文数，13，4567不是回文数。
任意一个正整数，如果其不是回文数，将该数交换高低位以后和原数相加得到一个新的数，如果新数不是回文数，重复这个变换，直到得到一个回文数为止。例如，57变换后得到132（57+75），132得到363（132+231），363是一个回文数。
曾经有数学家猜想：对于任意正整数，经过有限次上述变换以后，一定能得出一个回文数。至今这个猜想还没有被证明是对的。现在请你通过程序来验证。
输入格式
输入一行一个正整数n。
 输出格式
输出第一行一个正整数，表示得到一个回文数的最少变换次数。
接下来一行，输出变换过程，相邻的数之间用->“连接。输出格式可以参见样例。
保证最后生成的数在int范围内。
样例输入
349
样例输出
3349--->1292--->4213--->7337
 */
#include <iostream>
#include <cstdio>
using namespace std;

int num[1005];      //保存变换过程中的数字
int digital[1005];  //保存回文数字的每一位
bool judge(int x)
{

    int m=0;
    while(x)   //把x一位一位的向digital数组中存
    {
        digital[m++] = x % 10;
        x /= 10;
    }                                               //比较前半边与后半边的数是否相等，不论x是偶数还是奇数，
    for (int i = 0; i < m / 2; ++i) {               //都除以二(m是int类型，除二取小数点前整数。为基数时如12321，就只用比较前两位和后两位； 为偶数时如123321，就比较前三位和后三位)
        if(digital[i] != digital[m - 1 - i])        //为什么是 m-1-i？ --->  是因为下标i的取值范围是0到m-1， 第i个对应末尾就是 （m-1）-i 的个
            return false;
        else
            return true;
    }
}

int reset(int x) //把数字反转
{
    int num = 0;
    while (x)
    {
        num = num * 10 + x % 10;                    // 把一个数翻转过来，就只需要把每次求余的结果加上上一次求余结果*10
        x /= 10;                                    //除10，向前进一位处理
    }
    return num;
}

int main()
{
    int n,cnt = 0;  //cnt来记录转换加了多少次
    cin  >> n;
    num[cnt++] = n;     //先把这个数存在num当中
    while (!judge(n))
    {
        n += reset(n);
        num[cnt++] = n;
    }
    cout << cnt -1 <<endl;  //cnt-1,要排除这个数本身，才是转换的次数
    for (int i = 0; i < cnt; ++i) {
        if(i != cnt-1 )
        {
            cout << num[i] << "--->";
        }else
            cout << num[i] <<endl;
    }
    return 0;
}